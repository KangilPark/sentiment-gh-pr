[
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35914982",
    "pull_request_review_id": null,
    "id": 35914982,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTE0OTgy",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 33,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can we get a javadoc for the class?\n",
    "created_at": "2015-07-30T20:13:35Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35914982",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35914982"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35914982"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 33,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35920658",
    "pull_request_review_id": null,
    "id": 35920658,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTIwNjU4",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 41,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should add javadocs explaining the format that this is expected to be in, referencing the fact that `ClientBatchJob` is what populates the JobParameters with this as a single string.\n",
    "created_at": "2015-07-30T21:05:52Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35920658",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35920658"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35920658"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 41,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35921015",
    "pull_request_review_id": null,
    "id": 35921015,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTIxMDE1",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 41,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Given that I am anal when it comes to immutability and such: This Tasklet is meant to be immutable, so these values should all be passed into the constructor, not setters.\n\n``` xml\n<constructor-arg name=\"jobPath\" value=\"#{jobParameters[path]}\"/>\n```\n",
    "created_at": "2015-07-30T21:09:21Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35921015",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35921015"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35921015"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 41,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35924981",
    "pull_request_review_id": null,
    "id": 35924981,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI0OTgx",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 136,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "There should be a \"then\" joining those two lines.\n",
    "created_at": "2015-07-30T21:46:52Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35924981",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35924981"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35924981"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 136,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35925129",
    "pull_request_review_id": null,
    "id": 35925129,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI1MTI5",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths\n+\n+        static NodeAndExcludePaths fromPath(final String path) {\n+            //Remove leading '/'\n+            final String thisPath = path.replaceFirst('/', '')",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 145,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Actually, given the example in the javadoc, this would mess things up.\n\n\"foo/bar/doo\" -> {\"foobar\", \"/doo\"}\n",
    "created_at": "2015-07-30T21:48:07Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35925129",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35925129"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35925129"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 145,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35926016",
    "pull_request_review_id": null,
    "id": 35926016,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI2MDE2",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths\n+\n+        static NodeAndExcludePaths fromPath(final String path) {\n+            //Remove leading '/'\n+            final String thisPath = path.replaceFirst('/', '')",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 145,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Safer:\n\n``` groovy\nfinal thisPath = path.startsWith('/') ? path.substring(1) : path\n```\n",
    "created_at": "2015-07-30T21:57:18Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35926016",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35926016"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35926016"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 145,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35926912",
    "pull_request_review_id": null,
    "id": 35926912,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI2OTEy",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 141,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Either make this immutable (which I see from line 112 it is not) or explicitly declare that it's expected to mutate.\n",
    "created_at": "2015-07-30T22:07:45Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35926912",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35926912"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35926912"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 141,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35927524",
    "pull_request_review_id": null,
    "id": 35927524,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI3NTI0",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 50,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is better replaced by\n\n``` groovy\ndef jobPathSlash = jobPath + '/'\nif (excludePaths.any {!it.startsWith(jobPathSlash)})\n    throw new IllegalArgumentException(\"Not all exclude paths start with \\\"${jobPathSlash}\\\": ${excludePaths}\")\n```\n\nbecause then (assuming things have been changed over to constructor form and the valid format of `jobPath` has been assured) the real purpose of this check (that the exclude paths are all absolute) will be met, as well as guaranteeing that they are all relative to the jobPath.\n",
    "created_at": "2015-07-30T22:15:15Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35927524",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35927524"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35927524"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 50,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35927955",
    "pull_request_review_id": null,
    "id": 35927955,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI3OTU1",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 109,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Grammar Nazi: \"just add it to it is paths?\" :speak_no_evil: \n",
    "created_at": "2015-07-30T22:19:57Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35927955",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35927955"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35927955"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 109,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929238",
    "pull_request_review_id": null,
    "id": 35929238,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI5MjM4",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 50,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Even better, as I continue to think through this, would be\n\n``` groovy\ndef theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\ndef jobPathSlash = jobPath + '/'\nif (theExcludePaths.any {!it.startsWith(jobPathSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\nthis.excludePaths = theExcludePaths.collect { it.substring(jobPathSlash.length()) }\n```\n\nthen you can always treat the exclude paths as relative (since later they are converted that way anyway) **_and_** you've already validated that they are legit for the job path.\n",
    "created_at": "2015-07-30T22:34:35Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929238",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929238"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929238"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 50,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929381",
    "pull_request_review_id": null,
    "id": 35929381,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI5Mzgx",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 95,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is no longer needed if `excludePaths` is transformed to be relative when set.\n",
    "created_at": "2015-07-30T22:36:20Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929381",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929381"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929381"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 95,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929760",
    "pull_request_review_id": null,
    "id": 35929760,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI5NzYw",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths\n+\n+        static NodeAndExcludePaths fromPath(final String path) {\n+            //Remove leading '/'\n+            final String thisPath = path.replaceFirst('/', '')\n+            //We need to find the current node, and the remaining path e.g 'foo/bar/doo', node: foo, remaining path: /bar/doo\n+            final slashIndex = thisPath.indexOf('/')\n+            //There is no remaining path\n+            if(slashIndex == -1) {\n+                return new NodeAndExcludePaths(nodeName: thisPath, excludePaths: [])\n+            }\n+            final remainingPath = thisPath.substring(slashIndex)\n+            final node = thisPath - remainingPath",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 153,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "More efficient than the `minus(..)`\n\n``` groovy\nfinal node = thisPath.substring(0, slashIndex)\n```\n\nalso a bit clearer as to the intent and less likely to get caught on subtle bugs like `remainingPath` happening to be a substring in what is supposed to be `node`\n",
    "created_at": "2015-07-30T22:41:40Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929760",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929760"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929760"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 153,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929871",
    "pull_request_review_id": null,
    "id": 35929871,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI5ODcx",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths\n+\n+        static NodeAndExcludePaths fromPath(final String path) {\n+            //Remove leading '/'\n+            final String thisPath = path.replaceFirst('/', '')\n+            //We need to find the current node, and the remaining path e.g 'foo/bar/doo', node: foo, remaining path: /bar/doo\n+            final slashIndex = thisPath.indexOf('/')\n+            //There is no remaining path\n+            if(slashIndex == -1) {\n+                return new NodeAndExcludePaths(nodeName: thisPath, excludePaths: [])\n+            }\n+            final remainingPath = thisPath.substring(slashIndex)",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 152,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If you add 1 to the index then you're guaranteed to get a true relative path for the remaining path\n\n``` groovy\nfinal remainingPath = thisPath.substring(slashIndex+1)\n```\n",
    "created_at": "2015-07-30T22:43:08Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929871",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929871"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929871"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 152,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929981",
    "pull_request_review_id": null,
    "id": 35929981,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTI5OTgx",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath\n+        this.jobPath = thisJobPath\n+    }\n+\n+\n+    void setSlingRepository(SlingRepository slingRepository) {\n+        this.slingRepository = slingRepository\n+    }\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!excludePaths || excludePaths.empty) {\n+            final Node node = session.getNode(jobPath)\n+            node.remove()\n+        }\n+        else {\n+            deletePartialTree(session)\n+        }\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    private void deletePartialTree(final Session session) {\n+        final relativeExcludePaths = excludePaths.collect { it - jobPath }\n+        final relativeRoot = session.getNode(jobPath)\n+        deletePartialTree(relativeRoot, relativeExcludePaths)\n+    }\n+\n+\n+    private void deletePartialTree(Node rootNode, Collection<String> relativeExcludePaths) {\n+        //Base case.  If a root node does not have any exclude paths under it, it must have been excluded\n+        if(!relativeExcludePaths) {\n+            return\n+        }\n+        //Compute the current tree level excluded nodes, and compute the remaining paths to traverse\n+        Collection<NodeAndExcludePaths> nodeAndExcludePaths = relativeExcludePaths.inject([] as Collection<NodeAndExcludePaths>) { def acc, def thisPath ->\n+            final thisNodeAndExcludePath = NodeAndExcludePaths.fromPath(thisPath)\n+            //If we have already created a nodeAndExcludePath for this node name, just add to it's exclude paths\n+            final matchingNodeName = acc.find { it.nodeName == thisNodeAndExcludePath.nodeName }\n+            if(matchingNodeName) {\n+                matchingNodeName.excludePaths.addAll(thisNodeAndExcludePath.excludePaths)\n+            }\n+            else {\n+                acc.add(thisNodeAndExcludePath)\n+            }\n+            return acc\n+        } as Collection\n+        //Delete nodes allowed under this tree\n+        final rootNodeChildren = rootNode.getNodes()\n+        while(rootNodeChildren.hasNext()) {\n+            final currentNode = rootNodeChildren.nextNode()\n+            //If this node is in our exclusion list, don't delete it\n+            if(!(nodeAndExcludePaths.find { currentNode.name == it.nodeName })) {\n+                currentNode.remove()\n+            }\n+        }\n+        //Recurse on each\n+        nodeAndExcludePaths.each {\n+            deletePartialTree(rootNode.getNode(it.nodeName), it.excludePaths)\n+        }\n+    }\n+\n+    /**\n+     * If we have a path for a node such as 'foo/bar/doo'\n+     * node is 'foo', and the excludePaths is '/bar/doo'\n+     */\n+    static class NodeAndExcludePaths {\n+\n+        String nodeName\n+        Collection<String> excludePaths\n+\n+        static NodeAndExcludePaths fromPath(final String path) {\n+            //Remove leading '/'\n+            final String thisPath = path.replaceFirst('/', '')",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 145,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If `remainingPath` below, and `excludePaths` above are both guaranteed to be relative, then this whole piece about removing a leading `/` is no longer needed.\n",
    "created_at": "2015-07-30T22:44:28Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929981",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35929981"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35929981"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 145,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35930262",
    "pull_request_review_id": null,
    "id": 35930262,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM1OTMwMjYy",
    "diff_hunk": "@@ -0,0 +1,158 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.jcr.Node\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> excludePaths\n+\n+    private SlingRepository slingRepository\n+\n+    void setExcludePaths(String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            excludePaths = []\n+            return\n+        }\n+        Collection<String> theseExcludePaths = thisPathsString.split(\"\\\\*\") as Collection\n+        excludePaths = theseExcludePaths.collect { String excludePath ->\n+            return (excludePath[0] != '/') ? \"/${excludePath}\".toString() : excludePath\n+        }\n+    }\n+\n+\n+    void setJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        thisJobPath = thisJobPath[0] != '/' ? \"/${thisJobPath}\" : thisJobPath",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 56,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "ca7d5f83304c9972a70add4db321bcddcb89369b",
    "user": {
      "login": "jdigger",
      "id": 3276,
      "node_id": "MDQ6VXNlcjMyNzY=",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3276?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jdigger",
      "html_url": "https://github.com/jdigger",
      "followers_url": "https://api.github.com/users/jdigger/followers",
      "following_url": "https://api.github.com/users/jdigger/following{/other_user}",
      "gists_url": "https://api.github.com/users/jdigger/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jdigger/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jdigger/subscriptions",
      "organizations_url": "https://api.github.com/users/jdigger/orgs",
      "repos_url": "https://api.github.com/users/jdigger/repos",
      "events_url": "https://api.github.com/users/jdigger/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jdigger/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "May want to add\n\n``` groovy\nthisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2]\n```\n\nto guard against `/foo/` being passed in.\n",
    "created_at": "2015-07-30T22:47:53Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r35930262",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/35930262"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r35930262"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 56,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36012017",
    "pull_request_review_id": null,
    "id": 36012017,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDEyMDE3",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": 119,
    "original_position": 119,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Do we need a new session here? Can we not use the one persisted in `ThreadLocal`? (ClientBatchJobContext) ?\n",
    "created_at": "2015-07-31T20:16:37Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36012017",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36012017"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36012017"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36014682",
    "pull_request_review_id": null,
    "id": 36014682,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDE0Njgy",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "`clientWofkflowOff` is VERY lightweight step. Having said that, even if it is light weight, it actually does manage concurrency internally (so there is already multi-threading handling involved in the actual step and on that we are spawning different thread for the step it self).\n\nDo we know this split of steps is going to give us tangible benefits?\n\nIf not, then I vote we keep it simple and have the steps be sequential. If there are no tangible benefits, I think this way will be harder to maintain (as you know we already have 1 Thread Per Path in the config)\n\ncc: @jdigger \n",
    "created_at": "2015-07-31T20:46:22Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36014682",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36014682"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36014682"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36014966",
    "pull_request_review_id": null,
    "id": 36014966,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDE0OTY2",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+\n+        final Node rootNode\n+        try {\n+            rootNode = session.getNode(jobPath)\n+        }\n+        catch(PathNotFoundException ex) {\n+            log.warn \"deleteBeforeWrite was enabled for jobPath ${jobPath} but job path does not exist on client!\"\n+            return RepeatStatus.FINISHED\n+        }\n+\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!relativeExcludePaths || relativeExcludePaths.empty) {\n+            rootNode.remove()\n+        }\n+        else {\n+            deletePartialTree(rootNode, relativeExcludePaths)\n+        }\n+\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    /**\n+     * Called recursively taking a rootNode, and deleting any nodes adjacent except adjacent corresponding nodes form relativeExcludePaths",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 144,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I feel `and deleting any nodes adjacent except adjacent corresponding nodes form relativeExcludePaths` is a bit confusing and could be clearer :-)\n",
    "created_at": "2015-07-31T20:49:27Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36014966",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36014966"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36014966"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 144,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36015612",
    "pull_request_review_id": null,
    "id": 36015612,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDE1NjEy",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+\n+        final Node rootNode\n+        try {\n+            rootNode = session.getNode(jobPath)\n+        }\n+        catch(PathNotFoundException ex) {\n+            log.warn \"deleteBeforeWrite was enabled for jobPath ${jobPath} but job path does not exist on client!\"\n+            return RepeatStatus.FINISHED\n+        }\n+\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!relativeExcludePaths || relativeExcludePaths.empty) {\n+            rootNode.remove()\n+        }\n+        else {\n+            deletePartialTree(rootNode, relativeExcludePaths)\n+        }\n+\n+        session.save()",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": 138,
    "original_position": 138,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is just a suggestion (and open for discussion too :) )but you could implement a `DeleteBeforeWriteStepExecutionListener` that prepares (in this case, I guess there's nothing much to prepare; but you can do anything in it) and cleans up after the step (in this case would be `session.save()`)\n\nMay be it will be cleaner? :) (example : https://github.com/TWCable/grabbit/blob/master/grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/jcrnodes/JcrNodesStepExecutionListener.groovy )\n",
    "created_at": "2015-07-31T20:57:06Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36015612",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36015612"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36015612"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 138,
    "original_line": 138,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36016909",
    "pull_request_review_id": null,
    "id": 36016909,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDE2OTA5",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+\n+        final Node rootNode\n+        try {\n+            rootNode = session.getNode(jobPath)\n+        }\n+        catch(PathNotFoundException ex) {\n+            log.warn \"deleteBeforeWrite was enabled for jobPath ${jobPath} but job path does not exist on client!\"\n+            return RepeatStatus.FINISHED\n+        }\n+\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!relativeExcludePaths || relativeExcludePaths.empty) {\n+            rootNode.remove()",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": 132,
    "original_position": 132,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Wondering if there is a preference / difference between `node.remove()` and `session.removeItem(/path)` ?\n",
    "created_at": "2015-07-31T21:11:12Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36016909",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36016909"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36016909"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 132,
    "original_line": 132,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034741",
    "pull_request_review_id": null,
    "id": 36034741,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDM0NzQx",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "jbornemann",
      "id": 4540994,
      "node_id": "MDQ6VXNlcjQ1NDA5OTQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4540994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbornemann",
      "html_url": "https://github.com/jbornemann",
      "followers_url": "https://api.github.com/users/jbornemann/followers",
      "following_url": "https://api.github.com/users/jbornemann/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbornemann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbornemann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbornemann/subscriptions",
      "organizations_url": "https://api.github.com/users/jbornemann/orgs",
      "repos_url": "https://api.github.com/users/jbornemann/repos",
      "events_url": "https://api.github.com/users/jbornemann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbornemann/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Performance benefits are marginal at this point; but any small wins are great, especially since the complexity is managed by Spring Batch.  That said it's more to establish the pattern, that we should be doing independent tasks concurrently.\n\nI hope to move namespaceSync into preFlowSync eventually, but for the sake of keeping the PR small...\n\nThis will make this change will make performance gains more significant.\n",
    "created_at": "2015-08-01T16:08:43Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034741",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034741"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034741"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034749",
    "pull_request_review_id": null,
    "id": 36034749,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDM0NzQ5",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")\n+\n+        final Node rootNode\n+        try {\n+            rootNode = session.getNode(jobPath)\n+        }\n+        catch(PathNotFoundException ex) {\n+            log.warn \"deleteBeforeWrite was enabled for jobPath ${jobPath} but job path does not exist on client!\"\n+            return RepeatStatus.FINISHED\n+        }\n+\n+        //If we don't have any exclude paths, we don't have to worry about only clearing particular subtrees\n+        if(!relativeExcludePaths || relativeExcludePaths.empty) {\n+            rootNode.remove()\n+        }\n+        else {\n+            deletePartialTree(rootNode, relativeExcludePaths)\n+        }\n+\n+        session.save()\n+        return RepeatStatus.FINISHED\n+    }\n+\n+\n+    /**\n+     * Called recursively taking a rootNode, and deleting any nodes adjacent except adjacent corresponding nodes form relativeExcludePaths",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": null,
    "original_position": 144,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "jbornemann",
      "id": 4540994,
      "node_id": "MDQ6VXNlcjQ1NDA5OTQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4540994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbornemann",
      "html_url": "https://github.com/jbornemann",
      "followers_url": "https://api.github.com/users/jbornemann/followers",
      "following_url": "https://api.github.com/users/jbornemann/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbornemann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbornemann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbornemann/subscriptions",
      "organizations_url": "https://api.github.com/users/jbornemann/orgs",
      "repos_url": "https://api.github.com/users/jbornemann/repos",
      "events_url": "https://api.github.com/users/jbornemann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbornemann/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Oops, typo.  \n\nOpen to suggestions :-). I'll try to make it more clear \n",
    "created_at": "2015-08-01T16:09:58Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034749",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034749"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034749"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 144,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034805",
    "pull_request_review_id": null,
    "id": 36034805,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MDM0ODA1",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": 119,
    "original_position": 119,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "jbornemann",
      "id": 4540994,
      "node_id": "MDQ6VXNlcjQ1NDA5OTQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4540994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbornemann",
      "html_url": "https://github.com/jbornemann",
      "followers_url": "https://api.github.com/users/jbornemann/followers",
      "following_url": "https://api.github.com/users/jbornemann/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbornemann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbornemann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbornemann/subscriptions",
      "organizations_url": "https://api.github.com/users/jbornemann/orgs",
      "repos_url": "https://api.github.com/users/jbornemann/repos",
      "events_url": "https://api.github.com/users/jbornemann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbornemann/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This isn't managed by SimpleSynchronousTaskExecutioner (default) like clientJcrNodes, and namespaceSync are.  It's managed by it's async counterpart, so we can't rely on our ThreadLocal \"hack\".  \n\nThe session really only needs to be shared in clientJcrNodes in my opinion.  You probably know best with your research, but wondering if there is a better way to manage a session within clientJcrNodes ( Setting as a task executioner property maybe?) It's sort of an unfortunate leaky abstraction we have to rely on \n",
    "created_at": "2015-08-01T16:17:41Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034805",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36034805"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36034805"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36114979",
    "pull_request_review_id": null,
    "id": 36114979,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MTE0OTc5",
    "diff_hunk": "@@ -0,0 +1,214 @@\n+package com.twcable.grabbit.client.batch.steps.workspace\n+\n+import com.twcable.grabbit.jcr.JcrUtil\n+import groovy.transform.CompileStatic\n+import groovy.util.logging.Slf4j\n+import org.apache.sling.jcr.api.SlingRepository\n+import org.springframework.batch.core.StepContribution\n+import org.springframework.batch.core.scope.context.ChunkContext\n+import org.springframework.batch.core.step.tasklet.Tasklet\n+import org.springframework.batch.repeat.RepeatStatus\n+\n+import javax.annotation.Nonnull\n+import javax.annotation.Nullable\n+import javax.jcr.Node\n+import javax.jcr.PathNotFoundException\n+import javax.jcr.Session\n+\n+/*\n+ * Copyright 2015 Time Warner Cable, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * A client preSyncFlow tasklet that deletes nodes under the job path\n+ * <p>\n+ *     This tasklet is used to clear the workspace that will be written to by the job path.\n+ *     If exclude paths are provided, it does not delete those paths, rather it deletes the nodes\n+ *     around the exclude paths.  If no exclude paths are provided, the entire tree under the\n+ *     job path is deleted.\n+ *\n+ *     This tasklet is activated by the \"deleteBeforeWrite\" path configuration\n+ * </p>\n+ */\n+@Slf4j\n+@CompileStatic\n+class DeleteBeforeWriteTasklet implements Tasklet {\n+\n+    private String jobPath\n+\n+    private Collection<String> relativeExcludePaths\n+\n+    private SlingRepository slingRepository\n+\n+\n+    /**\n+     * @param jobPath the job path to evaluate.  Comes from the job parameters\n+     * @param slingRepository comes from bean defined in client-osgi-config.xml\n+     * @param excludePaths a '*' delimited string containing the paths to exclude.  Comes from the job parameters\n+     */\n+    DeleteBeforeWriteTasklet(@Nonnull final String jobPath, @Nonnull final SlingRepository slingRepository, @Nullable String excludePaths) {\n+        this.slingRepository = slingRepository\n+        //Ensures the job path leads with a '/'\n+        this.jobPath = cleanJobPath(jobPath)\n+        //Takes the * delimited paths string, creates a collection of relative paths, and normalizes\n+        this.relativeExcludePaths = createExcludePaths(this.jobPath, excludePaths)\n+    }\n+\n+\n+    /**\n+     * @param paths '*' delimited, expected to be driven from job parameters e.g /foo/bar/blah{@literal *}/foo/bar/meh\n+     * @param jobPath the job path, used to make sure we are building well-formed relative paths e.g /foo/bar\n+     * @return A collection of the exclude paths that are guaranteed to lead with a '/', e.g [blah, meh].  If null or empty, returns an empty collection\n+     * @throws IllegalStateException if any paths are not well-formed to the jobPath\n+     */\n+    private static Collection<String> createExcludePaths(@Nonnull final String jobPath, @Nullable String paths) {\n+        final thisPathsString = paths?.trim()\n+        if(!thisPathsString) {\n+            return []\n+        }\n+        final theExcludePaths = thisPathsString.split(\"\\\\*\") as Collection<String>\n+        final jobPathWithSlash = jobPath + '/'\n+\n+        if (theExcludePaths.any {!it.startsWith(jobPathWithSlash)}) throw new IllegalStateException(\"Not all exclude paths start with \\\"${jobPath}\\\": ${theExcludePaths}\")\n+\n+        return theExcludePaths.collect { it.substring(jobPathWithSlash.length()) }\n+    }\n+\n+    /**\n+     * @param jobPath expected to be driven from job parameters\n+     * @return a \"cleaned\" job path, i.e leads with a '/', no trailing '/', and trimmed, e.g \"/foo/bar\"\n+     */\n+    private static String cleanJobPath(String jobPath) {\n+        String thisJobPath = jobPath.trim()\n+        //Add the leading '/' if not present\n+        thisJobPath = (thisJobPath[0] != '/') ? \"/${thisJobPath}\" : thisJobPath\n+        //Remove any trailing '/'\n+        thisJobPath = (thisJobPath[-1] != '/') ? thisJobPath : thisJobPath[0..-2] as String\n+\n+        return thisJobPath\n+    }\n+\n+\n+    /**\n+     * Given the current context in the form of a step contribution, do whatever\n+     * is necessary to process this unit inside a transaction. Implementations\n+     * return {@link RepeatStatus#FINISHED} if finished. If not they return\n+     * {@link RepeatStatus#CONTINUABLE}. On failure throws an exception.\n+     *\n+     * @param contribution mutable state to be passed back to update the current\n+     * step execution\n+     * @param chunkContext attributes shared between invocations but not between\n+     * restarts\n+     * @return an {@link RepeatStatus} indicating whether processing is\n+     * continuable.\n+     */\n+    @Override\n+    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n+        final Session session = JcrUtil.getSession(slingRepository, \"admin\")",
    "path": "grabbit/src/main/groovy/com/twcable/grabbit/client/batch/steps/workspace/DeleteBeforeWriteTasklet.groovy",
    "position": 119,
    "original_position": 119,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Yes I know using ThreadLocal is kind of a last resort general but there were several things that made us use ThreadLocal instead of anything else.\n1. The design was simpler to have 1 session per path and we had to share the incoming input stream between steps anyways (not just `clientJcrNodes`)\n2. Originally, I was trying to use Spring Batch's `ExecutionContext` to store the session (and the input stream). But, Spring Batch discourages placing large objects in its ExecutionContext, which is understandable since ExecutionContext is one of the objects persisted in the `Spring Batch's Job Repository`.. which for our case, we have our `JcrJobRepository` layer.\n3. Hence, ThreadLocal was the last resort and if done properly, we know that it would always work and as mentioned above, we had to share the `inputStream` amongst the steps anyways.\n",
    "created_at": "2015-08-03T18:28:29Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36114979",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36114979"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36114979"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 119,
    "original_line": 119,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36115682",
    "pull_request_review_id": null,
    "id": 36115682,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MTE1Njgy",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I do think that using the feature will make sense in some cases, but I still don't think that parallelizing `clientWorkflowOffTasklet` and `deleteBeforeWriteTasklet` makes sense (and may be its not safe either). \n\nFor example : I think its perfectly reasonable to have a workflow that will trigger when a DAM Asset is removed (may be to remove `custom renditions` for that Asset or something).\n\nFor such a scenario, if we parallellize the two tasks above, it is possible that the nodes are removed before the corresponding workflows are turned off, which will result in undesirable effects.\n\nI could however see `nameSpaceSync` and `clientWorkflowOff` tasks being parallelized. I think that will be safe, but the current structure I do not think is safe in all the cases.\n\nWhat do others think @jdigger @jazeren1 @sikarwarvimal Paul?\n",
    "created_at": "2015-08-03T18:34:57Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36115682",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36115682"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36115682"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36317443",
    "pull_request_review_id": null,
    "id": 36317443,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3NDQz",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "jbornemann",
      "id": 4540994,
      "node_id": "MDQ6VXNlcjQ1NDA5OTQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4540994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbornemann",
      "html_url": "https://github.com/jbornemann",
      "followers_url": "https://api.github.com/users/jbornemann/followers",
      "following_url": "https://api.github.com/users/jbornemann/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbornemann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbornemann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbornemann/subscriptions",
      "organizations_url": "https://api.github.com/users/jbornemann/orgs",
      "repos_url": "https://api.github.com/users/jbornemann/repos",
      "events_url": "https://api.github.com/users/jbornemann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbornemann/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Although unlikely, I could see a case for that.  I'll revert it back to synchronous, and we can explore making nameSpaceSync, and deleteBeforeWrite concurrent at a later date.  \n",
    "created_at": "2015-08-05T15:45:46Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36317443",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36317443"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36317443"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36318656",
    "pull_request_review_id": null,
    "id": 36318656,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE4NjU2",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "jbornemann",
      "id": 4540994,
      "node_id": "MDQ6VXNlcjQ1NDA5OTQ=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/4540994?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jbornemann",
      "html_url": "https://github.com/jbornemann",
      "followers_url": "https://api.github.com/users/jbornemann/followers",
      "following_url": "https://api.github.com/users/jbornemann/following{/other_user}",
      "gists_url": "https://api.github.com/users/jbornemann/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jbornemann/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jbornemann/subscriptions",
      "organizations_url": "https://api.github.com/users/jbornemann/orgs",
      "repos_url": "https://api.github.com/users/jbornemann/repos",
      "events_url": "https://api.github.com/users/jbornemann/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jbornemann/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "https://github.com/TWCable/grabbit/issues/54\n",
    "created_at": "2015-08-05T15:55:37Z",
    "updated_at": "2015-08-05T22:49:57Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36318656",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "MEMBER",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36318656"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36318656"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36378729",
    "pull_request_review_id": null,
    "id": 36378729,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc4NzI5",
    "diff_hunk": "@@ -32,16 +32,35 @@\n     -->\n \n     <import resource=\"client-batch-job-context.xml\"/>\n+\n+    <import resource=\"client-namespace-step.xml\" />\n     <import resource=\"client-jcrNodes-step.xml\" />\n-    <import resource=\"client-preprocessor-step.xml\" />\n+    <import resource=\"client-deleteBeforeWrite-steps.xml\" />\n \n     <batch:job id=\"clientJob\" xmlns=\"http://www.springframework.org/schema/batch\" job-repository=\"clientJobRepository\">\n-        <batch:step id=\"clientPreprocessor\" next=\"clientWorkflowOff\">\n-            <batch:tasklet ref=\"clientPreprocessTasklet\" transaction-manager=\"clientTransactionManager\"/>\n-        </batch:step>\n-        <batch:step id=\"clientWorkflowOff\" next=\"clientJcrNodes\">\n-            <batch:tasklet ref=\"clientWorkflowOffTasklet\" transaction-manager=\"clientTransactionManager\"/>\n+        <!--  Do any presync tasks concurrently that we can, e.g turning off workflows -->\n+        <batch:split id=\"preSyncFlow\" task-executor=\"asyncTaskExecutor\" next=\"clientNamespaceSync\">\n+            <batch:flow>\n+                <batch:step id=\"clientWorkflowOff\">",
    "path": "grabbit/src/main/resources/META-INF/spring/client-batch-job.xml",
    "position": 19,
    "original_position": 19,
    "commit_id": "03c4654ce709f3829b9e7cba24c6abcc24814980",
    "original_commit_id": "e1e8674945fa9375600bd13fad1f986a1da27184",
    "user": {
      "login": "sagarsane",
      "id": 667114,
      "node_id": "MDQ6VXNlcjY2NzExNA==",
      "avatar_url": "https://avatars2.githubusercontent.com/u/667114?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sagarsane",
      "html_url": "https://github.com/sagarsane",
      "followers_url": "https://api.github.com/users/sagarsane/followers",
      "following_url": "https://api.github.com/users/sagarsane/following{/other_user}",
      "gists_url": "https://api.github.com/users/sagarsane/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sagarsane/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sagarsane/subscriptions",
      "organizations_url": "https://api.github.com/users/sagarsane/orgs",
      "repos_url": "https://api.github.com/users/sagarsane/repos",
      "events_url": "https://api.github.com/users/sagarsane/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sagarsane/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Cool. The revert will be done in a separate PR I presume?\n",
    "created_at": "2015-08-06T03:33:24Z",
    "updated_at": "2015-08-06T03:33:24Z",
    "html_url": "https://github.com/TWCable/grabbit/pull/48#discussion_r36378729",
    "pull_request_url": "https://api.github.com/repos/TWCable/grabbit/pulls/48",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/comments/36378729"
      },
      "html": {
        "href": "https://github.com/TWCable/grabbit/pull/48#discussion_r36378729"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/TWCable/grabbit/pulls/48"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 44,
    "original_line": 44,
    "side": "RIGHT"
  }
]
