[
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59489790",
    "pull_request_review_id": null,
    "id": 59489790,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NDg5Nzkw",
    "diff_hunk": "@@ -144,11 +147,11 @@ trait SubmissionComponent {\n \n       uniqueResult[SubmissionRecord](findById(UUID.fromString(submission.submissionId))) flatMap {\n         case None =>\n-          val configId = uniqueResult(methodConfigurationQuery.findByName(\n+          val configIdAction = uniqueResult[Long](methodConfigurationQuery.findByName(\n             workspaceContext.workspaceId, submission.methodConfigurationNamespace, submission.methodConfigurationName).map(_.id))\n \n           loadSubmissionEntityId(workspaceContext.workspaceId, submission.submissionEntity) flatMap { entityId =>\n-            configId flatMap { configId =>\n+            configIdAction flatMap { configId =>",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/dataaccess/slick/SubmissionComponent.scala",
    "position": 23,
    "original_position": 23,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "ea01bc6c4cf299936b5a4ecda3f37743a93fed3d",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this was just some unrelated confusion clean up\n",
    "created_at": "2016-04-13T03:52:28Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59489790",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59489790"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59489790"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 154,
    "original_line": 154,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59489989",
    "pull_request_review_id": null,
    "id": 59489989,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NDg5OTg5",
    "diff_hunk": "@@ -89,6 +89,9 @@ trait PerRequest extends Actor {\n       case (statusCode: StatusCode, payload: Any) =>\n         logResponse(statusCode, payload)\n         r.withHttpResponseHeadersMapped(h => h ++ headers).complete(response)\n+      case (statusCode: StatusCode) =>\n+        logResponse(statusCode, None)\n+        r.withHttpResponseHeadersMapped(h => h ++ headers).complete(response)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/webservice/PerRequest.scala",
    "position": 6,
    "original_position": 6,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "ea01bc6c4cf299936b5a4ecda3f37743a93fed3d",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this is an unrelated bug fix\n",
    "created_at": "2016-04-13T03:55:30Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59489989",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59489989"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59489989"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 94,
    "original_line": 94,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59490056",
    "pull_request_review_id": null,
    "id": 59490056,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NDkwMDU2",
    "diff_hunk": "@@ -1,21 +1,28 @@\n package org.broadinstitute.dsde.rawls.jobexec",
    "path": "src/test/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorSpec.scala",
    "position": 1,
    "original_position": 1,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "ea01bc6c4cf299936b5a4ecda3f37743a93fed3d",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this is pretty much completely rewritten, the diff is not helpful\n",
    "created_at": "2016-04-13T03:56:38Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59490056",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59490056"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59490056"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 1,
    "original_line": 1,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59569077",
    "pull_request_review_id": null,
    "id": 59569077,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTY5MDc3",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 124,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Can this match be moved up to queryExecutionServiceForStatus?  It would be a little clearer if this method took a WorkflowRecord without the Option.\n",
    "created_at": "2016-04-13T15:26:28Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59569077",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59569077"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59569077"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 124,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59573451",
    "pull_request_review_id": null,
    "id": 59573451,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTczNDUx",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 199,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "If the get is moved to getWorkspace (so it returns `ReadAction[Workspace]`) then any None.get errors will be closer to the immediate cause, so easier to debug if it ever happens.\n",
    "created_at": "2016-04-13T15:49:55Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59573451",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59573451"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59573451"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 199,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59574855",
    "pull_request_review_id": null,
    "id": 59574855,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTc0ODU1",
    "diff_hunk": "@@ -242,7 +242,7 @@ trait TestDriverComponent extends DriverComponent with DataAccess {\n     val methodConfig2 = MethodConfiguration(\"dsde\", \"testConfig2\", \"Sample\", Map(\"ready\"-> AttributeString(\"true\")), Map(\"param1\"-> AttributeString(\"foo\")), Map(\"out1\" -> AttributeString(\"bar\"), \"out2\" -> AttributeString(\"splat\")), MethodRepoMethod(wsName.namespace, \"method-a\", 1))\n     val methodConfig3 = MethodConfiguration(\"dsde\", \"testConfig\", \"Sample\", Map(\"ready\"-> AttributeString(\"true\")), Map(\"param1\"-> AttributeString(\"foo\"), \"param2\"-> AttributeString(\"foo2\")), Map(\"out\" -> AttributeString(\"bar\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))\n \n-    val methodConfigEntityUpdate = MethodConfiguration(\"ns\", \"testConfig1\", \"Sample\", Map(), Map(), Map(\"o1\" -> AttributeString(\"this.foo\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))\n+    val methodConfigEntityUpdate = MethodConfiguration(\"ns\", \"testConfig11\", \"Sample\", Map(), Map(), Map(\"o1\" -> AttributeString(\"this.foo\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))",
    "path": "src/test/scala/org/broadinstitute/dsde/rawls/dataaccess/slick/TestDriverComponent.scala",
    "position": 5,
    "original_position": 5,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Was this intentional? (probably doesn't matter either way)\n",
    "created_at": "2016-04-13T15:58:06Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59574855",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59574855"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59574855"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 245,
    "original_line": 245,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59577453",
    "pull_request_review_id": null,
    "id": 59577453,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTc3NDUz",
    "diff_hunk": "@@ -16,13 +17,12 @@ import scala.concurrent.duration._\n object SubmissionSupervisor {\n   sealed trait SubmissionSupervisorMessage\n \n-  case class SubmissionStarted(workspaceName: WorkspaceName, submissionId: String, credential: Credential)\n+  case class SubmissionStarted(workspaceName: WorkspaceName, submissionId: UUID, credential: Credential)\n \n   def props(executionServiceDAO: ExecutionServiceDAO,\n             datasource: SlickDataSource,\n-            workflowPollInterval: Duration = 1 minutes,\n-            submissionPollInterval: Duration = 30 minutes): Props = {\n-    Props(new SubmissionSupervisor(executionServiceDAO, datasource, workflowPollInterval, submissionPollInterval))\n+            submissionPollInterval: FiniteDuration = 1 minutes): Props = {",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionSupervisor.scala",
    "position": 28,
    "original_position": 28,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "is it worth pulling the duration out into config, so we can tune it per-environment? (brainstorming here, not suggesting)\n",
    "created_at": "2016-04-13T16:13:32Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59577453",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59577453"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59577453"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 24,
    "original_line": 24,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59580612",
    "pull_request_review_id": null,
    "id": 59580612,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgwNjEy",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 179,
    "original_position": 181,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "potentially add a debug log statement here, noting the date/time that we marked the submission finished? (I'd love to see that in the db table, but that's way out of scope for this PR)\n",
    "created_at": "2016-04-13T16:32:32Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59580612",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59580612"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59580612"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 179,
    "original_line": 181,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59580975",
    "pull_request_review_id": null,
    "id": 59580975,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgwOTc1",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 195,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "typo on \"outputExprepressions\" ... should be \"outputExpressions\"\n",
    "created_at": "2016-04-13T16:34:54Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59580975",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59580975"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59580975"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 195,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59581128",
    "pull_request_review_id": null,
    "id": 59581128,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgxMTI4",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 204,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "what happens on error in one of these three updates? Can/should this be transaction-ized?\n",
    "created_at": "2016-04-13T16:35:59Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59581128",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59581128"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59581128"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582562",
    "pull_request_review_id": null,
    "id": 59582562,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgyNTYy",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 199,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I can do it in the first instance mentioned but not here because the for comprehension is unwrapping things so getWorkspace(dataAccess) is not actually of type Option (although I could map it...) \n",
    "created_at": "2016-04-13T16:44:08Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582562",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582562"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582562"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 199,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582638",
    "pull_request_review_id": null,
    "id": 59582638,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgyNjM4",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>\n+        Try {\n+          attributeName.value -> outputs.getOrElse(outputName, {\n+            throw new RawlsException(s\"output named ${outputName} does not exist\")\n+          })\n+        }\n+      }\n+\n+      if (attributes.forall(_.isSuccess)) {\n+        Left(updateEntityAndWorkspace(entitiesById(workflowRecord.workflowEntityId.get), workspace, attributes.map(_.get).toMap))\n+\n+      } else {\n+        Right((workflowRecord, attributes.collect { case Failure(t) => AttributeString(t.getMessage) }.toSeq))\n+      }\n+    }\n+  }\n+\n+  def updateEntityAndWorkspace(entity: Entity, workspace: Workspace, workflowOutputs: Map[String, Attribute]): (Option[Entity], Option[Workspace]) = {\n+    //Partition outputs by whether their attributes are entity attributes (begin with \"this.\") or workspace ones (implicitly; begin with \"workspace.\")\n+    //This assumption (that it's either \"this.\" or \"workspace.\") will be guaranteed by checking of the method config when it's imported; see DSDEEPB-1603.\n+    //Yes I know this is a var but it's more terse this way.\n+    var (entityAttributes, workspaceAttributes) = workflowOutputs.partition({ case (k, v) => k.startsWith(\"this.\") })\n+    entityAttributes = entityAttributes.map({ case (k, v) => (k.stripPrefix(\"this.\"), v) })\n+    workspaceAttributes = workspaceAttributes.map({ case (k, v) => (k.stripPrefix(\"workspace.\"), v) })",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 261,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I hate vars :)\n\n```\nval (partitionEntity, partitionWorkspace) = workflowOutputs.partition({ case (k, v) => k.startsWith(\"this.\") })\nval entityAttributes = partitionEntity.map({ case (k, v) => (k.stripPrefix(\"this.\"), v) })\nval workspaceAttributes = partitionWorkspace.map({ case (k, v) => (k.stripPrefix(\"workspace.\"), v) })\n```\n",
    "created_at": "2016-04-13T16:44:35Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582638",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582638"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582638"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 261,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582681",
    "pull_request_review_id": null,
    "id": 59582681,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgyNjgx",
    "diff_hunk": "@@ -242,7 +242,7 @@ trait TestDriverComponent extends DriverComponent with DataAccess {\n     val methodConfig2 = MethodConfiguration(\"dsde\", \"testConfig2\", \"Sample\", Map(\"ready\"-> AttributeString(\"true\")), Map(\"param1\"-> AttributeString(\"foo\")), Map(\"out1\" -> AttributeString(\"bar\"), \"out2\" -> AttributeString(\"splat\")), MethodRepoMethod(wsName.namespace, \"method-a\", 1))\n     val methodConfig3 = MethodConfiguration(\"dsde\", \"testConfig\", \"Sample\", Map(\"ready\"-> AttributeString(\"true\")), Map(\"param1\"-> AttributeString(\"foo\"), \"param2\"-> AttributeString(\"foo2\")), Map(\"out\" -> AttributeString(\"bar\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))\n \n-    val methodConfigEntityUpdate = MethodConfiguration(\"ns\", \"testConfig1\", \"Sample\", Map(), Map(), Map(\"o1\" -> AttributeString(\"this.foo\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))\n+    val methodConfigEntityUpdate = MethodConfiguration(\"ns\", \"testConfig11\", \"Sample\", Map(), Map(), Map(\"o1\" -> AttributeString(\"this.foo\")), MethodRepoMethod(\"ns-config\", \"meth1\", 1))",
    "path": "src/test/scala/org/broadinstitute/dsde/rawls/dataaccess/slick/TestDriverComponent.scala",
    "position": 5,
    "original_position": 5,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "it was intentional, the name overlaps with another method config in the test fixture\n",
    "created_at": "2016-04-13T16:44:50Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582681",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582681"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582681"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 245,
    "original_line": 245,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582890",
    "pull_request_review_id": null,
    "id": 59582890,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgyODkw",
    "diff_hunk": "@@ -16,13 +17,12 @@ import scala.concurrent.duration._\n object SubmissionSupervisor {\n   sealed trait SubmissionSupervisorMessage\n \n-  case class SubmissionStarted(workspaceName: WorkspaceName, submissionId: String, credential: Credential)\n+  case class SubmissionStarted(workspaceName: WorkspaceName, submissionId: UUID, credential: Credential)\n \n   def props(executionServiceDAO: ExecutionServiceDAO,\n             datasource: SlickDataSource,\n-            workflowPollInterval: Duration = 1 minutes,\n-            submissionPollInterval: Duration = 30 minutes): Props = {\n-    Props(new SubmissionSupervisor(executionServiceDAO, datasource, workflowPollInterval, submissionPollInterval))\n+            submissionPollInterval: FiniteDuration = 1 minutes): Props = {",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionSupervisor.scala",
    "position": 28,
    "original_position": 28,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "it is written to be configurable but has not been a priority to push it all the way into config\n",
    "created_at": "2016-04-13T16:46:16Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582890",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59582890"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59582890"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 24,
    "original_line": 24,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59583035",
    "pull_request_review_id": null,
    "id": 59583035,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgzMDM1",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 179,
    "original_position": 181,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "there is a debug log in the receive of the actor... do you think that is good enough?\n",
    "created_at": "2016-04-13T16:47:15Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59583035",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59583035"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59583035"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 179,
    "original_line": 181,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59583280",
    "pull_request_review_id": null,
    "id": 59583280,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTgzMjgw",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 204,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "it is in a transaction, the transaction demarcation is in handleStatusResponses\n",
    "created_at": "2016-04-13T16:48:39Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59583280",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59583280"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59583280"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59590795",
    "pull_request_review_id": null,
    "id": 59590795,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTkwNzk1",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>\n+        Try {\n+          attributeName.value -> outputs.getOrElse(outputName, {\n+            throw new RawlsException(s\"output named ${outputName} does not exist\")\n+          })\n+        }\n+      }\n+\n+      if (attributes.forall(_.isSuccess)) {\n+        Left(updateEntityAndWorkspace(entitiesById(workflowRecord.workflowEntityId.get), workspace, attributes.map(_.get).toMap))\n+\n+      } else {\n+        Right((workflowRecord, attributes.collect { case Failure(t) => AttributeString(t.getMessage) }.toSeq))\n+      }\n+    }\n+  }\n+\n+  def updateEntityAndWorkspace(entity: Entity, workspace: Workspace, workflowOutputs: Map[String, Attribute]): (Option[Entity], Option[Workspace]) = {\n+    //Partition outputs by whether their attributes are entity attributes (begin with \"this.\") or workspace ones (implicitly; begin with \"workspace.\")\n+    //This assumption (that it's either \"this.\" or \"workspace.\") will be guaranteed by checking of the method config when it's imported; see DSDEEPB-1603.\n+    //Yes I know this is a var but it's more terse this way.\n+    var (entityAttributes, workspaceAttributes) = workflowOutputs.partition({ case (k, v) => k.startsWith(\"this.\") })\n+    entityAttributes = entityAttributes.map({ case (k, v) => (k.stripPrefix(\"this.\"), v) })\n+    workspaceAttributes = workspaceAttributes.map({ case (k, v) => (k.stripPrefix(\"workspace.\"), v) })",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 261,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this is actually copied from the old code, it works so I left it alone but if you want me to change it I will\n",
    "created_at": "2016-04-13T17:34:32Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59590795",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59590795"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59590795"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 261,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59600997",
    "pull_request_review_id": null,
    "id": 59600997,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjAwOTk3",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 107,
    "original_position": 107,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "this is a pretty small query ... but I think it's doing a table scan. Potentially we would benefit from an index on the STATUS column.\n\nWill mysql use the foreign key index (WORKFLOW.SUBMISSION_ID->SUBMISSION.ID) when querying on submissionId, without the join to the submission table?\n",
    "created_at": "2016-04-13T18:32:18Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59600997",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59600997"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59600997"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 107,
    "original_line": 107,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59604677",
    "pull_request_review_id": null,
    "id": 59604677,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA0Njc3",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 238,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "spelling\n",
    "created_at": "2016-04-13T18:53:02Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59604677",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59604677"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59604677"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 238,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59605243",
    "pull_request_review_id": null,
    "id": 59605243,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA1MjQz",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 107,
    "original_position": 107,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "explain plan shows it is using the FK index:\n\n```\nMySQL [rawls]> explain select `ID`, `EXTERNAL_ID`, `SUBMISSION_ID`, `STATUS`, `STATUS_LAST_CHANGED`, `ENTITY_ID` from `WORKFLOW` where `SUBMISSION_ID` = 0x043AE84815084E74A7C027ECC3308B6C and STATUS in (\"Submitted\", \"Running\", \"Aborting\");\n+----+-------------+----------+------+---------------+-----------+---------+-------+------+------------------------------------+\n| id | select_type | table    | type | possible_keys | key       | key_len | ref   | rows | Extra                              |\n+----+-------------+----------+------+---------------+-----------+---------+-------+------+------------------------------------+\n|  1 | SIMPLE      | WORKFLOW | ref  | FK_WF_SUB     | FK_WF_SUB | 16      | const |   37 | Using index condition; Using where |\n+----+-------------+----------+------+---------------+-----------+---------+-------+------+------------------------------------+\n```\n",
    "created_at": "2016-04-13T18:56:37Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59605243",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59605243"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59605243"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 107,
    "original_line": 107,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59605513",
    "pull_request_review_id": null,
    "id": 59605513,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA1NTEz",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>\n+        Try {\n+          attributeName.value -> outputs.getOrElse(outputName, {\n+            throw new RawlsException(s\"output named ${outputName} does not exist\")\n+          })\n+        }\n+      }\n+\n+      if (attributes.forall(_.isSuccess)) {\n+        Left(updateEntityAndWorkspace(entitiesById(workflowRecord.workflowEntityId.get), workspace, attributes.map(_.get).toMap))\n+\n+      } else {\n+        Right((workflowRecord, attributes.collect { case Failure(t) => AttributeString(t.getMessage) }.toSeq))\n+      }\n+    }\n+  }\n+\n+  def updateEntityAndWorkspace(entity: Entity, workspace: Workspace, workflowOutputs: Map[String, Attribute]): (Option[Entity], Option[Workspace]) = {\n+    //Partition outputs by whether their attributes are entity attributes (begin with \"this.\") or workspace ones (implicitly; begin with \"workspace.\")\n+    //This assumption (that it's either \"this.\" or \"workspace.\") will be guaranteed by checking of the method config when it's imported; see DSDEEPB-1603.\n+    //Yes I know this is a var but it's more terse this way.",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 258,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": ":-1: \n",
    "created_at": "2016-04-13T18:58:11Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59605513",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59605513"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59605513"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 258,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59606552",
    "pull_request_review_id": null,
    "id": 59606552,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA2NTUy",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 204,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Be consistent for all 3 about collecting here vs. collect in the function - either way is fine\n",
    "created_at": "2016-04-13T19:04:45Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59606552",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59606552"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59606552"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 204,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59606961",
    "pull_request_review_id": null,
    "id": 59606961,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA2OTYx",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>\n+        Try {\n+          attributeName.value -> outputs.getOrElse(outputName, {\n+            throw new RawlsException(s\"output named ${outputName} does not exist\")\n+          })\n+        }\n+      }\n+\n+      if (attributes.forall(_.isSuccess)) {\n+        Left(updateEntityAndWorkspace(entitiesById(workflowRecord.workflowEntityId.get), workspace, attributes.map(_.get).toMap))\n+\n+      } else {\n+        Right((workflowRecord, attributes.collect { case Failure(t) => AttributeString(t.getMessage) }.toSeq))\n+      }\n+    }\n+  }\n+\n+  def updateEntityAndWorkspace(entity: Entity, workspace: Workspace, workflowOutputs: Map[String, Attribute]): (Option[Entity], Option[Workspace]) = {\n+    //Partition outputs by whether their attributes are entity attributes (begin with \"this.\") or workspace ones (implicitly; begin with \"workspace.\")\n+    //This assumption (that it's either \"this.\" or \"workspace.\") will be guaranteed by checking of the method config when it's imported; see DSDEEPB-1603.\n+    //Yes I know this is a var but it's more terse this way.\n+    var (entityAttributes, workspaceAttributes) = workflowOutputs.partition({ case (k, v) => k.startsWith(\"this.\") })\n+    entityAttributes = entityAttributes.map({ case (k, v) => (k.stripPrefix(\"this.\"), v) })\n+    workspaceAttributes = workspaceAttributes.map({ case (k, v) => (k.stripPrefix(\"workspace.\"), v) })\n+\n+    val updatedEntity = if (entityAttributes.isEmpty) None else Option(entity.copy(attributes = entity.attributes ++ entityAttributes))\n+    val updatedWorkspace = if (workspaceAttributes.isEmpty) None else Option(workspace.copy(attributes = workspace.attributes ++ workspaceAttributes))\n+    \n+    (updatedEntity, updatedWorkspace)\n+  }\n+\n+  def saveErrors(errors: Seq[(WorkflowRecord, Seq[AttributeString])], dataAccess: DataAccess) = {\n+    DBIO.sequence(errors.map { case (workflowRecord, errorMessages) =>\n+      dataAccess.workflowQuery.filter(_.id === workflowRecord.id).update(workflowRecord.copy(status = WorkflowStatuses.Failed.toString)) andThen\n+        dataAccess.workflowQuery.saveMessages(errorMessages, workflowRecord.id)\n+    })\n+  }\n+\n+  private def getUserInfo = {\n+    val expiresInSeconds: Long = Option(credential.getExpiresInSeconds).map(_.toLong).getOrElse(0)\n+    if (expiresInSeconds <= 5*60) {",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 275,
    "original_position": 278,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Should this be configurable?  If so, make a JIRA to do it later rather than bothering for now.\n",
    "created_at": "2016-04-13T19:07:04Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59606961",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59606961"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59606961"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 275,
    "original_line": 278,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59607631",
    "pull_request_review_id": null,
    "id": 59607631,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA3NjMx",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 199,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "ok\n",
    "created_at": "2016-04-13T19:11:27Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59607631",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59607631"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59607631"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 199,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59608165",
    "pull_request_review_id": null,
    "id": 59608165,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjA4MTY1",
    "diff_hunk": "@@ -25,229 +32,294 @@ class SubmissionMonitorSpec(_system: ActorSystem) extends TestKit(_system) with\n     super.afterAll\n   }\n \n-  //actorSelection isn't super reliable, so this function waits for workflow actors to spin up and returns a map from workflowId -> wfActor\n-  private def waitForWorkflowActors(workspaceContext: SlickWorkspaceContext, submission: Submission, subMonActor: TestActorRef[SubmissionMonitor]) = {\n-    val wfActors = MMap[String, ActorRef]()\n+  private def await[T](f: Future[T]): T = Await.result(f, 5 minutes)\n \n-    val workflowsWithIds = runAndWait(workflowQuery.getWithWorkflowIds(workspaceContext, submission.submissionId))\n+  \"SubmissionMonitory\" should \"queryExecutionServiceForStatus success\" in withDefaultTestDatabase { dataSource: SlickDataSource =>",
    "path": "src/test/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorSpec.scala",
    "position": null,
    "original_position": 43,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "0659ee41e447134e38f53754bceb77c019fda1bb",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "spelling\n",
    "created_at": "2016-04-13T19:15:11Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59608165",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59608165"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59608165"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 37,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59611171",
    "pull_request_review_id": null,
    "id": 59611171,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjExMTcx",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)\n+      } else {\n+        DBIO.successful(false)\n+      }\n+    }\n+  }\n+\n+  def handleOutputs(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess)(implicit executionContext: ExecutionContext) = {\n+    if (workflowsWithOutputs.isEmpty) {\n+      DBIO.successful(Unit)\n+    } else {\n+      for {\n+        // load all the starting data\n+        entitiesById <-         listWorkflowEntitiesById(workflowsWithOutputs, dataAccess)\n+        outputExprepressions <- listMethodConfigOutputsForSubmission(dataAccess)\n+        workspaceOption <-      getWorkspace(dataAccess)\n+\n+        // update the appropriate entities and workspace (in memory)\n+        updatedEntitiesAndWorkspace = attachOutputs(workspaceOption.get, workflowsWithOutputs, entitiesById, outputExprepressions)\n+\n+        // save everything to the db\n+        _ <- saveWorkspace(dataAccess, updatedEntitiesAndWorkspace)\n+        _ <- saveEntities(dataAccess, workspaceOption.get, updatedEntitiesAndWorkspace)\n+        _ <- saveErrors(updatedEntitiesAndWorkspace.collect { case Right(errors) => errors }, dataAccess)\n+      } yield Unit\n+    }\n+  }\n+\n+  def getWorkspace(dataAccess: DataAccess): ReadAction[Option[Workspace]] = {\n+    dataAccess.workspaceQuery.findByName(workspaceName)\n+  }\n+\n+  def listMethodConfigOutputsForSubmission(dataAccess: DataAccess): ReadAction[Map[String, String]] = {\n+    dataAccess.submissionQuery.getMethodConfigOutputExpressions(submissionId)\n+  }\n+\n+  def listWorkflowEntitiesById(workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], dataAccess: DataAccess): ReadAction[Map[UUID, Entity]] = {\n+    dataAccess.entityQuery.listByIds(workflowsWithOutputs.map { case (workflowRec, outputs) => workflowRec.workflowEntityId.get })\n+  }\n+\n+  def saveWorkspace(dataAccess: DataAccess, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    //note there is only 1 workspace (may be None if it is not updated) even though it may be updated multiple times so reduce it into 1 update\n+    val workspaces = updatedEntitiesAndWorkspace.collect { case Left((_, Some(workspace))) => workspace }\n+    if (workspaces.isEmpty) DBIO.successful(0)\n+    else dataAccess.workspaceQuery.save(workspaces.reduce((a, b) => a.copy(attributes = a.attributes ++ b.attributes)))\n+  }\n+\n+  def saveEntities(dataAccess: DataAccess, workspace: Workspace, updatedEntitiesAndWorkspace: Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, scala.Seq[AttributeString])]]) = {\n+    val entities = updatedEntitiesAndWorkspace.collect { case Left((Some(entity), _)) => entity }\n+    if (entities.isEmpty) DBIO.successful(0)\n+    else dataAccess.entityQuery.save(SlickWorkspaceContext(workspace), entities)\n+  }\n+\n+  def attachOutputs(workspace: Workspace, workflowsWithOutputs: Seq[(WorkflowRecord, ExecutionServiceOutputs)], entitiesById: Map[UUID, Entity], outputExprepressions: Map[String, String]): Seq[Either[(Option[Entity], Option[Workspace]), (WorkflowRecord, Seq[AttributeString])]] = {\n+    workflowsWithOutputs.map { case (workflowRecord, outputsResponse) =>\n+      val outputs = outputsResponse.outputs\n+\n+      val attributes = outputExprepressions.map { case (outputName, attributeName) =>\n+        Try {\n+          attributeName.value -> outputs.getOrElse(outputName, {\n+            throw new RawlsException(s\"output named ${outputName} does not exist\")\n+          })\n+        }\n+      }\n+\n+      if (attributes.forall(_.isSuccess)) {\n+        Left(updateEntityAndWorkspace(entitiesById(workflowRecord.workflowEntityId.get), workspace, attributes.map(_.get).toMap))\n+\n+      } else {\n+        Right((workflowRecord, attributes.collect { case Failure(t) => AttributeString(t.getMessage) }.toSeq))\n+      }\n+    }\n+  }\n+\n+  def updateEntityAndWorkspace(entity: Entity, workspace: Workspace, workflowOutputs: Map[String, Attribute]): (Option[Entity], Option[Workspace]) = {\n+    //Partition outputs by whether their attributes are entity attributes (begin with \"this.\") or workspace ones (implicitly; begin with \"workspace.\")\n+    //This assumption (that it's either \"this.\" or \"workspace.\") will be guaranteed by checking of the method config when it's imported; see DSDEEPB-1603.\n+    //Yes I know this is a var but it's more terse this way.",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": null,
    "original_position": 258,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "jmthibault79",
      "id": 2701406,
      "node_id": "MDQ6VXNlcjI3MDE0MDY=",
      "avatar_url": "https://avatars2.githubusercontent.com/u/2701406?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jmthibault79",
      "html_url": "https://github.com/jmthibault79",
      "followers_url": "https://api.github.com/users/jmthibault79/followers",
      "following_url": "https://api.github.com/users/jmthibault79/following{/other_user}",
      "gists_url": "https://api.github.com/users/jmthibault79/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jmthibault79/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jmthibault79/subscriptions",
      "organizations_url": "https://api.github.com/users/jmthibault79/orgs",
      "repos_url": "https://api.github.com/users/jmthibault79/repos",
      "events_url": "https://api.github.com/users/jmthibault79/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jmthibault79/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "(fixed, thanks!)\n",
    "created_at": "2016-04-13T19:35:54Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59611171",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59611171"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59611171"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 258,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59614131",
    "pull_request_review_id": null,
    "id": 59614131,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE0MTMx",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 107,
    "original_position": 107,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Try doing the explain, but leaving out the `SUBMISSION_ID = 0x043AE84815084E74A7C027ECC3308B6C` clause - in other words, just filtering by status. Explain shows it's doing a full scan on that. I suspect with both clauses, it filters first to the submissionId, then does a scan over the remainder of records. I don't know how much another index would optimize this, but I know for sure the statuses are not indexed.\n",
    "created_at": "2016-04-13T19:55:48Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59614131",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59614131"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59614131"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 107,
    "original_line": 107,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59614756",
    "pull_request_review_id": null,
    "id": 59614756,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE0NzU2",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)\n+    } flatMap { externalWorkflowIds =>\n+      Future.traverse(externalWorkflowIds) { workflowRec =>\n+        // for each workflow query the exec service for status and if has Succeeded query again for outputs\n+        toFutureTry(execServiceStatus(workflowRec) flatMap execServiceOutputs)\n+      }\n+    } map (ExecutionServiceStatusResponse)\n+  }\n+\n+  private def execServiceStatus(workflowRec: WorkflowRecord)(implicit executionContext: ExecutionContext): Future[Option[WorkflowRecord]] = {\n+    executionServiceDAO.status(workflowRec.externalId, getUserInfo).map(newStatus => {\n+      if (newStatus.status != workflowRec.status) Option(workflowRec.copy(status = newStatus.status))\n+      else None\n+    })\n+  }\n+\n+  private def execServiceOutputs(workflowRecOption: Option[WorkflowRecord])(implicit executionContext: ExecutionContext): Future[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]] = {\n+    workflowRecOption match {\n+      case Some(workflowRec) =>\n+        WorkflowStatuses.withName(workflowRec.status) match {\n+          case WorkflowStatuses.Succeeded =>\n+            executionServiceDAO.outputs(workflowRec.externalId, getUserInfo).map(outputs => Option((workflowRec, Option(outputs))))\n+\n+          case _ => Future.successful(Option((workflowRec, None)))\n+        }\n+      case None => Future(None)\n+\n+    }\n+  }\n+\n+  /**\n+   * once all the execution service queries have completed this function is called to handle the responses\n+   * @param response\n+   * @param executionContext\n+   * @return\n+   */\n+  def handleStatusResponses(response: ExecutionServiceStatusResponse)(implicit executionContext: ExecutionContext): Future[StatusCheckComplete] = {\n+    response.statusResponse.collect { case Failure(t) => t }.foreach { t =>\n+      logger.error(s\"Failure monitoring workflow in submission $submissionId\", t)\n+    }\n+\n+    datasource.inTransaction { dataAccess =>\n+      val updatedRecs = response.statusResponse.collect {\n+        case Success(Some((updatedRec, _))) => updatedRec\n+      }\n+\n+      val workflowsWithOutputs = response.statusResponse.collect {\n+        case Success(Some((workflowRec, Some(outputs)))) => (workflowRec, outputs)\n+      }\n+\n+      // to minimize database updates do 1 update per status\n+      DBIO.seq(updatedRecs.groupBy(_.status).map { case (status, recs) =>\n+        dataAccess.workflowQuery.findWorkflowByIds(recs.map(_.id)).map(r => (r.status, r.statusLastChangedDate)).update(status, new Timestamp(System.currentTimeMillis()))\n+      }.toSeq: _*) andThen\n+        handleOutputs(workflowsWithOutputs, dataAccess) andThen\n+        checkOverallStatus(dataAccess)\n+    } map { shouldStop => StatusCheckComplete(shouldStop) }\n+  }\n+\n+  /**\n+   * When there are no workflows with a running status, mark the submission as done or aborted as appropriate.\n+   * @param dataAccess\n+   * @param executionContext\n+   * @return true if the submission is done/aborted\n+   */\n+  def checkOverallStatus(dataAccess: DataAccess)(implicit executionContext: ExecutionContext): ReadWriteAction[Boolean] = {\n+    dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses:_*) flatMap { workflowRecs =>\n+      if (workflowRecs.isEmpty) {\n+        dataAccess.submissionQuery.findById(submissionId).map(_.status).result.head.map { status =>\n+          SubmissionStatuses.withName(status) match {\n+            case SubmissionStatuses.Aborting => SubmissionStatuses.Aborted\n+            case SubmissionStatuses.Submitted => SubmissionStatuses.Done\n+            case _ => throw new RawlsException(s\"submission $submissionId in unexpected state $status, expected Aborting or Submitted\")\n+          }\n+        } flatMap { newStatus => dataAccess.submissionQuery.updateStatus(submissionId, newStatus) } map(_ => true)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 179,
    "original_position": 181,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "the actor receive log message just states that the actor is checking to see if a submission can be finished (\"\"handling execution service response ...\"). I'd like to see - not super urgent - a message that the monitor actually did close a submission, and with which status.\n",
    "created_at": "2016-04-13T19:59:43Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59614756",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59614756"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59614756"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 179,
    "original_line": 181,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59615122",
    "pull_request_review_id": null,
    "id": 59615122,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1MTIy",
    "diff_hunk": "@@ -25,229 +32,294 @@ class SubmissionMonitorSpec(_system: ActorSystem) extends TestKit(_system) with\n     super.afterAll\n   }\n \n-  //actorSelection isn't super reliable, so this function waits for workflow actors to spin up and returns a map from workflowId -> wfActor\n-  private def waitForWorkflowActors(workspaceContext: SlickWorkspaceContext, submission: Submission, subMonActor: TestActorRef[SubmissionMonitor]) = {\n-    val wfActors = MMap[String, ActorRef]()\n+  private def await[T](f: Future[T]): T = Await.result(f, 5 minutes)\n \n-    val workflowsWithIds = runAndWait(workflowQuery.getWithWorkflowIds(workspaceContext, submission.submissionId))\n+  \"SubmissionMonitory\" should \"queryExecutionServiceForStatus success\" in withDefaultTestDatabase { dataSource: SlickDataSource =>",
    "path": "src/test/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorSpec.scala",
    "position": null,
    "original_position": 43,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "0659ee41e447134e38f53754bceb77c019fda1bb",
    "user": {
      "login": "davidangb",
      "id": 6041577,
      "node_id": "MDQ6VXNlcjYwNDE1Nzc=",
      "avatar_url": "https://avatars1.githubusercontent.com/u/6041577?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/davidangb",
      "html_url": "https://github.com/davidangb",
      "followers_url": "https://api.github.com/users/davidangb/followers",
      "following_url": "https://api.github.com/users/davidangb/following{/other_user}",
      "gists_url": "https://api.github.com/users/davidangb/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/davidangb/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/davidangb/subscriptions",
      "organizations_url": "https://api.github.com/users/davidangb/orgs",
      "repos_url": "https://api.github.com/users/davidangb/repos",
      "events_url": "https://api.github.com/users/davidangb/events{/privacy}",
      "received_events_url": "https://api.github.com/users/davidangb/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Scala does have StringLike ... JavaScript has truthy/falsey ... SubmissionMonitory sounds like fun\n",
    "created_at": "2016-04-13T20:02:08Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59615122",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59615122"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59615122"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": null,
    "original_line": 37,
    "side": "RIGHT"
  },
  {
    "url": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59643805",
    "pull_request_review_id": null,
    "id": 59643805,
    "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjQzODA1",
    "diff_hunk": "@@ -0,0 +1,283 @@\n+package org.broadinstitute.dsde.rawls.jobexec\n+\n+import java.sql.Timestamp\n+\n+import akka.actor._\n+import com.google.api.client.auth.oauth2.Credential\n+import com.typesafe.scalalogging.LazyLogging\n+import org.broadinstitute.dsde.rawls.RawlsException\n+import org.broadinstitute.dsde.rawls.dataaccess._\n+import org.broadinstitute.dsde.rawls.jobexec.SubmissionMonitorActor._\n+import org.broadinstitute.dsde.rawls.model._\n+import org.broadinstitute.dsde.rawls.util.FutureSupport\n+import spray.http.OAuth2BearerToken\n+import scala.concurrent.duration.{FiniteDuration, Duration}\n+import scala.util.{Success, Try, Failure}\n+import org.broadinstitute.dsde.rawls.dataaccess.slick.{ReadWriteAction, ReadAction, WorkflowRecord, DataAccess}\n+import scala.concurrent.{ExecutionContext, Future}\n+import akka.pattern._\n+import java.util.UUID\n+\n+/**\n+ * Created by dvoet on 6/26/15.\n+ */\n+object SubmissionMonitorActor {\n+  def props(workspaceName: WorkspaceName,\n+            submissionId: UUID,\n+            datasource: SlickDataSource,\n+            executionServiceDAO: ExecutionServiceDAO,\n+            credential: Credential,\n+            submissionPollInterval: FiniteDuration): Props = {\n+    Props(new SubmissionMonitorActor(workspaceName, submissionId, datasource, executionServiceDAO, credential, submissionPollInterval))\n+  }\n+\n+  sealed trait SubmissionMonitorMessage\n+  case object StartMonitorPass extends SubmissionMonitorMessage\n+\n+  /**\n+   * The response from querying the exec services.\n+   * @param statusResponse If a successful response shows an unchanged status there\n+   * will be a Success(None) entry in the statusResponse Seq. If the status has changed it will be\n+   * Some(workflowRecord, outputsOption) where workflowRecord will have the updated status. When the workflow\n+   * has Succeeded and there are outputs, outputsOption will contain the response from the exec service.\n+   */\n+  case class ExecutionServiceStatusResponse(statusResponse: Seq[Try[Option[(WorkflowRecord, Option[ExecutionServiceOutputs])]]]) extends SubmissionMonitorMessage\n+  case class StatusCheckComplete(terminateActor: Boolean) extends SubmissionMonitorMessage\n+}\n+\n+/**\n+ * An actor that monitors the status of a submission. Wakes up every submissionPollInterval and queries\n+ * the execution service for status of workflows that we don't think are done yet. For any workflows\n+ * that are successful, query again for outputs. Once all workflows are done mark the submission as done\n+ * and terminate the actor.\n+ *\n+ * @param submissionId id of submission to monitor\n+ * @param datasource\n+ * @param submissionPollInterval time between polls of db for all workflow statuses within submission\n+ */\n+class SubmissionMonitorActor(val workspaceName: WorkspaceName,\n+                             val submissionId: UUID,\n+                             val datasource: SlickDataSource,\n+                             val executionServiceDAO: ExecutionServiceDAO,\n+                             val credential: Credential,\n+                             val submissionPollInterval: FiniteDuration) extends Actor with SubmissionMonitor with LazyLogging {\n+\n+  import context._\n+\n+  scheduleNextMonitorPass\n+\n+  override def receive = {\n+    case StartMonitorPass =>\n+      logger.debug(s\"polling workflows for submission $submissionId\")\n+      queryExecutionServiceForStatus() pipeTo self\n+    case response: ExecutionServiceStatusResponse =>\n+      logger.debug(s\"handling execution service response for submission $submissionId\")\n+      handleStatusResponses(response) pipeTo self\n+    case StatusCheckComplete(terminateActor) =>\n+      logger.debug(s\"done checking status for submission $submissionId, terminateActor = $terminateActor\")\n+      if (terminateActor) stop(self)\n+      else scheduleNextMonitorPass\n+\n+    case Status.Failure(t) => throw t // an error happened in some future, let the supervisor handle it\n+  }\n+\n+  def scheduleNextMonitorPass: Cancellable = {\n+    system.scheduler.scheduleOnce(submissionPollInterval, self, StartMonitorPass)\n+  }\n+\n+}\n+\n+trait SubmissionMonitor extends FutureSupport with LazyLogging {\n+  val workspaceName: WorkspaceName\n+  val submissionId: UUID\n+  val datasource: SlickDataSource\n+  val executionServiceDAO: ExecutionServiceDAO\n+  val credential: Credential\n+  val submissionPollInterval: Duration\n+\n+  import datasource.dataAccess.driver.api._\n+\n+  /**\n+   * This function starts a monitoring pass\n+   * @param executionContext\n+   * @return\n+   */\n+  def queryExecutionServiceForStatus()(implicit executionContext: ExecutionContext): Future[ExecutionServiceStatusResponse] = {\n+    datasource.inTransaction { dataAccess =>\n+      dataAccess.workflowQuery.listWorkflowRecsForSubmissionAndStatuses(submissionId, WorkflowStatuses.runningStatuses: _*)",
    "path": "src/main/scala/org/broadinstitute/dsde/rawls/jobexec/SubmissionMonitorActor.scala",
    "position": 107,
    "original_position": 107,
    "commit_id": "656437f23c83e8167bb9ea0174ddba59eebfaa4d",
    "original_commit_id": "6073f854bcacb95ac23a8ae4d049dbb243ae25c2",
    "user": {
      "login": "dvoet",
      "id": 1521333,
      "node_id": "MDQ6VXNlcjE1MjEzMzM=",
      "avatar_url": "https://avatars0.githubusercontent.com/u/1521333?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dvoet",
      "html_url": "https://github.com/dvoet",
      "followers_url": "https://api.github.com/users/dvoet/followers",
      "following_url": "https://api.github.com/users/dvoet/following{/other_user}",
      "gists_url": "https://api.github.com/users/dvoet/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dvoet/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dvoet/subscriptions",
      "organizations_url": "https://api.github.com/users/dvoet/orgs",
      "repos_url": "https://api.github.com/users/dvoet/repos",
      "events_url": "https://api.github.com/users/dvoet/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dvoet/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "I am sure it would do a full table scan without the submission id but what does that prove? The query that we run uses the submission id.\n\nAnyway, there is probably benefit to having it so we can query for all running workflows, etc.\n",
    "created_at": "2016-04-13T23:32:01Z",
    "updated_at": "2016-04-14T16:30:57Z",
    "html_url": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59643805",
    "pull_request_url": "https://api.github.com/repos/broadinstitute/rawls/pulls/383",
    "author_association": "CONTRIBUTOR",
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/comments/59643805"
      },
      "html": {
        "href": "https://github.com/broadinstitute/rawls/pull/383#discussion_r59643805"
      },
      "pull_request": {
        "href": "https://api.github.com/repos/broadinstitute/rawls/pulls/383"
      }
    },
    "start_line": null,
    "original_start_line": null,
    "start_side": null,
    "line": 107,
    "original_line": 107,
    "side": "RIGHT"
  }
]
